//
//  MapViewViewController.swift
//  FIIT-PDT-Project
//
//  Created by Tomáš Anda on 24/10/2018.
//  Copyright (c) 2018 FIIT-PDT. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import Mapbox
import SwiftyJSON
import GEOSwift

protocol MapViewDisplayLogic: class
{
    func displaySomething(viewModel: MapView.Something.ViewModel)
}

// MGLAnnotation protocol reimplementation

class CustomPointAnnotation: NSObject, MGLAnnotation {
    // As a reimplementation of the MGLAnnotation protocol, we have to add mutable coordinate and (sub)title properties ourselves.
    var coordinate: CLLocationCoordinate2D
    var title: String?
    var subtitle: String?

    // Custom properties that we will use to customize the annotation's image.
    var image: UIImage?
    var reuseIdentifier: String?

    init(coordinate: CLLocationCoordinate2D, title: String?, subtitle: String?) {
        self.coordinate = coordinate
        self.title = title
        self.subtitle = subtitle
    }
}

// MGLPolyline subclass
class CustomPolyline: MGLPolyline {
    // Because this is a subclass of MGLPolyline, there is no need to redeclare its properties.

    // Custom property that we will use when drawing the polyline.
    var color: UIColor?
}


class MapViewViewController: UIViewController, MapViewDisplayLogic
{

    @IBOutlet weak var mapView: MGLMapView!

    @IBOutlet weak var testButton: UIButton!

    var timer: Timer?
    var polylineSource: MGLShapeSource?
    var currentIndex = 1
    var allCoordinates: [CLLocationCoordinate2D]!

    var interactor: MapViewBusinessLogic?
    var router: (NSObjectProtocol & MapViewRoutingLogic & MapViewDataPassing)?

    // MARK: Object lifecycle

    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?)
    {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        setup()
    }

    required init?(coder aDecoder: NSCoder)
    {
        super.init(coder: aDecoder)
        setup()
    }

    // MARK: Setup

    private func setup()
    {
        let viewController = self
        let interactor = MapViewInteractor()
        let presenter = MapViewPresenter()
        let router = MapViewRouter()
        viewController.interactor = interactor
        viewController.router = router
        interactor.presenter = presenter
        presenter.viewController = viewController
        router.viewController = viewController
        router.dataStore = interactor
    }

    // MARK: Routing

    override func prepare(for segue: UIStoryboardSegue, sender: Any?)
    {
        if let scene = segue.identifier {
            let selector = NSSelectorFromString("routeTo\(scene)WithSegue:")
            if let router = router, router.responds(to: selector) {
                router.perform(selector, with: segue)
            }
        }
    }

    // MARK: View lifecycle

    override func viewDidLoad()
    {
        super.viewDidLoad()
        setupMapView()
    }

    func setupMapView() {
        mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight]
        mapView.setCenter(CLLocationCoordinate2D(latitude: 42.328192, longitude: -71.896136), zoomLevel: 7, animated: false)
        mapView.delegate = self
    }

    // MARK: Do something

    //@IBOutlet weak var nameTextField: UITextField!

    func doSomething()
    {
        let request = MapView.Something.Request()
        interactor?.doSomething(request: request)
    }

    func displaySomething(viewModel: MapView.Something.ViewModel)
    {
        //nameTextField.text = viewModel.name
    }

    func addPolyline(to style: MGLStyle) {
        // Add an empty MGLShapeSource, we’ll keep a reference to this and add points to this later.
        let source = MGLShapeSource(identifier: "polyline", shape: nil, options: nil)
        style.addSource(source)
        polylineSource = source

        // Add a layer to style our polyline.
        let layer = MGLLineStyleLayer(identifier: "polyline", source: source)
        layer.lineJoin = NSExpression(forConstantValue: "round")
        layer.lineCap = NSExpression(forConstantValue: "round")
        layer.lineColor = NSExpression(forConstantValue: UIColor.red)

        // The line width should gradually increase based on the zoom level.
        layer.lineWidth = NSExpression(format: "mgl_interpolate:withCurveType:parameters:stops:($zoomLevel, 'linear', nil, %@)",
                                       [14: 5, 18: 20])
        style.addLayer(layer)
    }

    func animatePolyline() {
        currentIndex = 1

        // Start a timer that will simulate adding points to our polyline. This could also represent coordinates being added to our polyline from another source, such as a CLLocationManagerDelegate.
        timer = Timer.scheduledTimer(timeInterval: 0.01, target: self, selector: #selector(tick), userInfo: nil, repeats: true)
    }

    @objc func tick() {
        if currentIndex > allCoordinates.count {
            timer?.invalidate()
            timer = nil
            return
        }

        // Create a subarray of locations up to the current index.
        let coordinates = Array(allCoordinates[0..<currentIndex])

        // Update our MGLShapeSource with the current locations.
        updatePolylineWithCoordinates(coordinates: coordinates)

        currentIndex += 1
    }

    func updatePolylineWithCoordinates(coordinates: [CLLocationCoordinate2D]) {
        var mutableCoordinates = coordinates

        let polyline = MGLPolylineFeature(coordinates: &mutableCoordinates, count: UInt(mutableCoordinates.count))

        // Updating the MGLShapeSource’s shape will have the map redraw our polyline with the current coordinates.
        polylineSource?.shape = polyline
    }

    func addPoints() {

        let mapWorker = MapWorker()

        mapWorker.getPointsGeomCollection(completion: { geomCollection in

            if let geomCollection = geomCollection {

                var coordinates: [CLLocationCoordinate2D] = []

                for geom in geomCollection.geomCollection {
                    for coord in geom.coordinates {
                        coordinates.append(coord)
                    }
                }

                for coord in coordinates {
                    // Declare the marker `hello` and set its coordinates, title, and subtitle.
                    let hello = MGLPointAnnotation()
                    hello.coordinate = CLLocationCoordinate2D(latitude: coord.latitude, longitude: coord.longitude)
                    hello.title = "MS"
                    hello.subtitle = "Prison"

                    // Add marker `hello` to the map.
                    self.mapView.addAnnotation(hello)
                }




            }

        })

    }

    func addLinesv2() {

        let mapWorker = MapWorker()

        mapWorker.getGeomCollection(completion: { geomCollection in

            if let geomCollection = geomCollection {

                var coordinates: [CLLocationCoordinate2D] = []

                for geom in geomCollection.geomCollection {
                    for coord in geom.coordinates {
                        coordinates.append(coord)
                    }
                }
                //
                //                var coordinates: [CLLocationCoordinate2D] = [
                //                    CLLocationCoordinate2D(latitude: 37.77, longitude: -122.42),
                //                    CLLocationCoordinate2D(latitude: 38.91, longitude: -77.04),
                //                    ]
                let polyline = MGLPolylineFeature(coordinates: &coordinates, count: UInt(coordinates.count))
                let source = MGLShapeSource(identifier: "lines", features: [polyline], options: nil)
                self.mapView.style?.addSource(source)
                self.mapView.reloadStyle(nil)

                self.mapView.reloadInputViews()
                self.mapView.style?.addSource(source)

            }

        })





        //        // Convert the file contents to a shape collection feature object
        //        let data = try Data(contentsOf: url)
        //
        //        guard let shapeCollectionFeature = try MGLShape(data: data, encoding: String.Encoding.utf8.rawValue) as? MGLShapeCollectionFeature else {
        //            fatalError("Could not cast to specified MGLShapeCollectionFeature")
        //        }
        //
        //        if let polyline = shapeCollectionFeature.shapes.first as? MGLPolylineFeature {
        //            // Optionally set the title of the polyline, which can be used for:
        //            //  - Callout view
        //            //  - Object identification
        //            polyline.title = polyline.attributes["name"] as? String
        //
        //            // Add the annotation on the main thread
        //            DispatchQueue.main.async(execute: {
        //                // Unowned reference to self to prevent retain cycle
        //                [unowned self] in
        //                self.mapView.addAnnotation(polyline)
        //            })
        //        }
    }

    func addLinesv3() {

        let mapWorker = MapWorker()

        mapWorker.getGeomCollection(completion: { geomCollection in

            if let geomCollection = geomCollection {

                var coordinates: [CLLocationCoordinate2D] = []

                for geom in geomCollection.geomCollection {
                    for coord in geom.coordinates {
                        coordinates.append(coord)
                    }
                }

                // Convert the route’s coordinates into a polyline
                var routeCoordinates = coordinates
                let polyline = MGLPolylineFeature(coordinates: &routeCoordinates, count: UInt(coordinates.count))

                // If there's already a route line on the map, reset its shape to the new route
                if let source = self.mapView.style?.source(withIdentifier: "route-source") as? MGLShapeSource {
                    source.shape = polyline
                } else {
                    let source = MGLShapeSource(identifier: "route-source", features: [polyline], options: nil)

                    // Customize the route line color and width
                    let lineStyle = MGLLineStyleLayer(identifier: "route-style", source: source)
                    lineStyle.lineColor = NSExpression(forConstantValue: #colorLiteral(red: 0.1897518039, green: 0.3010634184, blue: 0.7994888425, alpha: 1))
                    lineStyle.lineWidth = NSExpression(forConstantValue: 2)

                    // Add the source and style layer of the route line to the map
                    self.mapView.style?.addSource(source)
                    self.mapView.style?.addLayer(lineStyle)
                }

            }

        })

    }


    func addLinesv4() {

        let mapWorker = MapWorker()

        mapWorker.getGeomCollection(completion: { geomCollection in

            if let geomCollection = geomCollection {

                var coordinates: [CLLocationCoordinate2D] = []

                for geom in geomCollection.geomCollection {
                    for coord in geom.coordinates {
                        coordinates.append(coord)
                        //break
                    }
                }

                coordinates.removeDuplicates()
                let c = coordinates.uniqueElements
                print(c.count)


                let polyline = CustomPolyline(coordinates: &coordinates, count: UInt(coordinates.count))

                // Set the custom `color` property, later used in the `mapView:strokeColorForShapeAnnotation:` delegate method.
                polyline.color = .darkGray

                // Add the polyline to the map. Note that this method name is singular.
                self.mapView.addAnnotation(polyline)

                // Point Annotations
                // Add a custom point annotation for every coordinate (vertex) in the polyline.
                var pointAnnotations = [CustomPointAnnotation]()
                for coordinate in coordinates {
                    let count = pointAnnotations.count + 1
                    let point = CustomPointAnnotation(coordinate: coordinate,
                                                      title: "Custom Point Annotation \(count)",
                        subtitle: nil)

                    // Set the custom `image` and `reuseIdentifier` properties, later used in the `mapView:imageForAnnotation:` delegate method.
                    // Create a unique reuse identifier for each new annotation image.
                    point.reuseIdentifier = "customAnnotation\(count)"
                    // This dot image grows in size as more annotations are added to the array.
                    //                    point.image = self.dot(size: 0 * count)

                    // Append each annotation to the array, which will be added to the map all at once.
                    pointAnnotations.append(point)
                }

                // Add the point annotations to the map. This time the method name is plural.
                // If you have multiple annotations to add, batching their addition to the map is more efficient.
                self.mapView.addAnnotations(pointAnnotations)



            }

        })

    }

    func addLinesv5() {

        let mapWorker = MapWorker()

        mapWorker.getTestJSON(completion: { resGeoJson in

            if let geoJ = resGeoJson {

                if let geoJson: Data = try? geoJ[0][0].rawData() {
                    // Add our GeoJSON data to the map as an MGLGeoJSONSource.
                    // We can then reference this data from an MGLStyleLayer.

                    // MGLMapView.style is optional, so you must guard against it not being set.
                    guard let style = self.mapView.style else { return }

                    guard let shapeFromGeoJSON = try? MGLShape(data: geoJson, encoding: String.Encoding.utf8.rawValue) else {
                        fatalError("Could not generate MGLShape")
                    }

                    let source = MGLShapeSource(identifier: "polyline", shape: shapeFromGeoJSON, options: nil)
                    style.addSource(source)

                    // Create new layer for the line.
                    let layer = MGLLineStyleLayer(identifier: "polyline", source: source)

                    // Set the line join and cap to a rounded end.
                    layer.lineJoin = NSExpression(forConstantValue: "round")
                    layer.lineCap = NSExpression(forConstantValue: "round")

                    // Set the line color to a constant blue color.
                    layer.lineColor = NSExpression(forConstantValue: UIColor(red: 59/255, green: 178/255, blue: 208/255, alpha: 1))

                    // Use `NSExpression` to smoothly adjust the line width from 2pt to 20pt between zoom levels 14 and 18. The `interpolationBase` parameter allows the values to interpolate along an exponential curve.
                    layer.lineWidth = NSExpression(format: "mgl_interpolate:withCurveType:parameters:stops:($zoomLevel, 'linear', nil, %@)",
                                                   [14: 2, 18: 20])

                    // We can also add a second layer that will draw a stroke around the original line.
                    let casingLayer = MGLLineStyleLayer(identifier: "polyline-case", source: source)
                    // Copy these attributes from the main line layer.
                    casingLayer.lineJoin = layer.lineJoin
                    casingLayer.lineCap = layer.lineCap
                    // Line gap width represents the space before the outline begins, so should match the main line’s line width exactly.
                    casingLayer.lineGapWidth = layer.lineWidth
                    // Stroke color slightly darker than the line color.
                    casingLayer.lineColor = NSExpression(forConstantValue: UIColor(red: 41/255, green: 145/255, blue: 171/255, alpha: 1))
                    // Use `NSExpression` to gradually increase the stroke width between zoom levels 14 and 18.
                    casingLayer.lineWidth = NSExpression(format: "mgl_interpolate:withCurveType:parameters:stops:($zoomLevel, 'linear', nil, %@)", [14: 1, 18: 4])

                    // Just for fun, let’s add another copy of the line with a dash pattern.
                    let dashedLayer = MGLLineStyleLayer(identifier: "polyline-dash", source: source)
                    dashedLayer.lineJoin = layer.lineJoin
                    dashedLayer.lineCap = layer.lineCap
                    dashedLayer.lineColor = NSExpression(forConstantValue: UIColor.white)
                    dashedLayer.lineOpacity = NSExpression(forConstantValue: 0.5)
                    dashedLayer.lineWidth = layer.lineWidth
                    // Dash pattern in the format [dash, gap, dash, gap, ...]. You’ll want to adjust these values based on the line cap style.
                    dashedLayer.lineDashPattern = NSExpression(forConstantValue: [0, 1.5])

                    style.addLayer(layer)
                    style.addLayer(dashedLayer)
                    style.insertLayer(casingLayer, below: layer)
                }


            }

        })

    }

    func getTheShortestPathForStationsAB() {

        let mapWorker = MapWorker()

        mapWorker.getTheShortestPathBetweenTwoStations(stationA: "springfield", stationB: "fitchburg", completion: { resGeoJson in

            if let geoJ = resGeoJson {

                if let geoJson: Data = try? geoJ[0][0].rawData() {
                    // Add our GeoJSON data to the map as an MGLGeoJSONSource.
                    // We can then reference this data from an MGLStyleLayer.

                    // MGLMapView.style is optional, so you must guard against it not being set.
                    guard let style = self.mapView.style else { return }

                    guard let shapeFromGeoJSON = try? MGLShape(data: geoJson, encoding: String.Encoding.utf8.rawValue) else {
                        fatalError("Could not generate MGLShape")
                    }

                    let source = MGLShapeSource(identifier: "shortestPathAB", shape: shapeFromGeoJSON, options: nil)
                    style.addSource(source)

                    // Create new layer for the line.
                    let layer = MGLLineStyleLayer(identifier: "shortestPathAB", source: source)

                    // Set the line join and cap to a rounded end.
                    layer.lineJoin = NSExpression(forConstantValue: "round")
                    layer.lineCap = NSExpression(forConstantValue: "round")

                    // Set the line color to a constant blue color.
                    layer.lineColor = NSExpression(forConstantValue: UIColor(red: 59/255, green: 178/255, blue: 208/255, alpha: 1))

                    // Use `NSExpression` to smoothly adjust the line width from 2pt to 20pt between zoom levels 14 and 18. The `interpolationBase` parameter allows the values to interpolate along an exponential curve.
                    layer.lineWidth = NSExpression(format: "mgl_interpolate:withCurveType:parameters:stops:($zoomLevel, 'linear', nil, %@)",
                                                   [14: 2, 18: 20])

                    // We can also add a second layer that will draw a stroke around the original line.
                    let casingLayer = MGLLineStyleLayer(identifier: "polyline-case", source: source)
                    // Copy these attributes from the main line layer.
                    casingLayer.lineJoin = layer.lineJoin
                    casingLayer.lineCap = layer.lineCap
                    // Line gap width represents the space before the outline begins, so should match the main line’s line width exactly.
                    casingLayer.lineGapWidth = layer.lineWidth
                    // Stroke color slightly darker than the line color.
                    casingLayer.lineColor = NSExpression(forConstantValue: UIColor(red: 41/255, green: 145/255, blue: 171/255, alpha: 1))
                    // Use `NSExpression` to gradually increase the stroke width between zoom levels 14 and 18.
                    casingLayer.lineWidth = NSExpression(format: "mgl_interpolate:withCurveType:parameters:stops:($zoomLevel, 'linear', nil, %@)", [14: 1, 18: 4])

                    // Just for fun, let’s add another copy of the line with a dash pattern.
                    let dashedLayer = MGLLineStyleLayer(identifier: "polyline-dash", source: source)
                    dashedLayer.lineJoin = layer.lineJoin
                    dashedLayer.lineCap = layer.lineCap
                    dashedLayer.lineColor = NSExpression(forConstantValue: UIColor.white)
                    dashedLayer.lineOpacity = NSExpression(forConstantValue: 0.5)
                    dashedLayer.lineWidth = layer.lineWidth
                    // Dash pattern in the format [dash, gap, dash, gap, ...]. You’ll want to adjust these values based on the line cap style.
                    dashedLayer.lineDashPattern = NSExpression(forConstantValue: [0, 1.5])

                    style.addLayer(layer)
                    //                    style.addLayer(dashedLayer)
                    //                    style.insertLayer(casingLayer, below: layer)
                }


            }

        })

    }

    func getTheShortestPathForStationsABC() {

        let mapWorker = MapWorker()

        mapWorker.getTheShortestPathBetweenThreeStations(stationA: "springfield", stationB: "worcester", stationC: "greenfield", completion: { resGeoJson in

            if let geoJ = resGeoJson {

                if let geoJson: Data = try? geoJ[0][0].rawData() {
                    // Add our GeoJSON data to the map as an MGLGeoJSONSource.
                    // We can then reference this data from an MGLStyleLayer.

                    // MGLMapView.style is optional, so you must guard against it not being set.
                    guard let style = self.mapView.style else { return }

                    guard let shapeFromGeoJSON = try? MGLShape(data: geoJson, encoding: String.Encoding.utf8.rawValue) else {
                        fatalError("Could not generate MGLShape")
                    }

                    let source = MGLShapeSource(identifier: "polyline", shape: shapeFromGeoJSON, options: nil)
                    style.addSource(source)

                    // Create new layer for the line.
                    let layer = MGLLineStyleLayer(identifier: "polyline", source: source)

                    // Set the line join and cap to a rounded end.
                    layer.lineJoin = NSExpression(forConstantValue: "round")
                    layer.lineCap = NSExpression(forConstantValue: "round")

                    // Set the line color to a constant blue color.
                    layer.lineColor = NSExpression(forConstantValue: UIColor(red: 230/255, green: 178/255, blue: 200/255, alpha: 1))

                    // Use `NSExpression` to smoothly adjust the line width from 2pt to 20pt between zoom levels 14 and 18. The `interpolationBase` parameter allows the values to interpolate along an exponential curve.
                    layer.lineWidth = NSExpression(format: "mgl_interpolate:withCurveType:parameters:stops:($zoomLevel, 'linear', nil, %@)",
                                                   [14: 2, 18: 20])

                    // We can also add a second layer that will draw a stroke around the original line.
                    let casingLayer = MGLLineStyleLayer(identifier: "polyline-case", source: source)
                    // Copy these attributes from the main line layer.
                    casingLayer.lineJoin = layer.lineJoin
                    casingLayer.lineCap = layer.lineCap
                    // Line gap width represents the space before the outline begins, so should match the main line’s line width exactly.
                    casingLayer.lineGapWidth = layer.lineWidth
                    // Stroke color slightly darker than the line color.
                    casingLayer.lineColor = NSExpression(forConstantValue: UIColor(red: 41/255, green: 145/255, blue: 171/255, alpha: 1))
                    // Use `NSExpression` to gradually increase the stroke width between zoom levels 14 and 18.
                    casingLayer.lineWidth = NSExpression(format: "mgl_interpolate:withCurveType:parameters:stops:($zoomLevel, 'linear', nil, %@)", [14: 1, 18: 4])

                    // Just for fun, let’s add another copy of the line with a dash pattern.
                    let dashedLayer = MGLLineStyleLayer(identifier: "polyline-dash", source: source)
                    dashedLayer.lineJoin = layer.lineJoin
                    dashedLayer.lineCap = layer.lineCap
                    dashedLayer.lineColor = NSExpression(forConstantValue: UIColor.white)
                    dashedLayer.lineOpacity = NSExpression(forConstantValue: 0.5)
                    dashedLayer.lineWidth = layer.lineWidth
                    // Dash pattern in the format [dash, gap, dash, gap, ...]. You’ll want to adjust these values based on the line cap style.
                    dashedLayer.lineDashPattern = NSExpression(forConstantValue: [0, 1.5])

                    style.addLayer(layer)
                    style.addLayer(dashedLayer)
                    style.insertLayer(casingLayer, below: layer)
                }


            }

        })

    }

    func createHeatmap() {

        let mapWorker = MapWorker()

        mapWorker.getHeatmapData(completion: { resGeoJson in

            if let geoJ = resGeoJson {

                if let geoJson: Data = try? geoJ[0][0].rawData() {
                    // Add our GeoJSON data to the map as an MGLGeoJSONSource.
                    // We can then reference this data from an MGLStyleLayer.

                    // MGLMapView.style is optional, so you must guard against it not being set.
                    guard let style = self.mapView.style else { return }

                    guard let shapeFromGeoJSON = try? MGLShape(data: geoJson, encoding: String.Encoding.utf8.rawValue) else {
                        fatalError("Could not generate MGLShape")
                    }

                    // If there's already a heamappoints on the map, do nothing
                    if let _ = self.mapView.style?.source(withIdentifier: "heamappoints") as? MGLShapeSource {
                        return
                    } else {

                        let source = MGLShapeSource(identifier: "heamappoints", shape: shapeFromGeoJSON, options: nil)
                        style.addSource(source)

                        // Create a heatmap layer.
                        let heatmapLayer = MGLHeatmapStyleLayer(identifier: "heamappoints", source: source)

                        // Adjust the color of the heatmap based on the point density.
                        let colorDictionary: [NSNumber: UIColor] = [
                            0.0: .clear,
                            0.01: .white,
                            0.15: UIColor(red: 0.19, green: 0.30, blue: 0.80, alpha: 1.0),
                            0.5: UIColor(red: 0.73, green: 0.23, blue: 0.25, alpha: 1.0),
                            1: .yellow
                        ]
                        heatmapLayer.heatmapColor = NSExpression(format: "mgl_interpolate:withCurveType:parameters:stops:($heatmapDensity, 'linear', nil, %@)", colorDictionary)

                        // Heatmap weight measures how much a single data point impacts the layer's appearance.
                        heatmapLayer.heatmapWeight = NSExpression(format: "mgl_interpolate:withCurveType:parameters:stops:(mag, 'linear', nil, %@)",
                                                                  [0: 0,
                                                                   1: 1])

                        // Heatmap intensity multiplies the heatmap weight based on zoom level.
                        heatmapLayer.heatmapIntensity = NSExpression(format: "mgl_interpolate:withCurveType:parameters:stops:($zoomLevel, 'linear', nil, %@)",
                                                                     [0: 1,
                                                                      1: 1])
                        heatmapLayer.heatmapRadius = NSExpression(format: "mgl_interpolate:withCurveType:parameters:stops:($zoomLevel, 'linear', nil, %@)",
                                                                  [0: 4,
                                                                   4: 5])

                        // The heatmap layer should be visible up to zoom level 9.
                        //                    heatmapLayer.heatmapOpacity = NSExpression(format: "mgl_step:from:stops:($zoomLevel, 0.75, %@)", [0: 0.75, 9: 0])
                        style.addLayer(heatmapLayer)

                        //                        Add a circle layer to represent the points at higher zoom levels.
                        //                        let circleLayer = MGLCircleStyleLayer(identifier: "circle-layer", source: source)
                        //
                        //                        let magnitudeDictionary: [NSNumber: UIColor] = [
                        //                            0: .white,
                        //                            0.5: .yellow,
                        //                            2.5: UIColor(red: 0.73, green: 0.23, blue: 0.25, alpha: 1.0),
                        //                            5: UIColor(red: 0.19, green: 0.30, blue: 0.80, alpha: 1.0)
                        //                        ]
                        //                        circleLayer.circleColor = NSExpression(format: "mgl_interpolate:withCurveType:parameters:stops:(mag, 'linear', nil, %@)", magnitudeDictionary)
                        //
                        //                        // The heatmap layer will have an opacity of 0.75 up to zoom level 9, when the opacity becomes 0.
                        //                        circleLayer.circleOpacity = NSExpression(format: "mgl_step:from:stops:($zoomLevel, 0, %@)", [0: 0, 9: 0.75])
                        //                        circleLayer.circleRadius = NSExpression(forConstantValue: 20)
                        //                        style.addLayer(circleLayer)
                    }


                }


            }

        })

    }

    func addAnnotations() {

        let mapWorker = MapWorker()

        mapWorker.getHeatmapData(completion: { resGeoJson in

            if let geoJ = resGeoJson {

                if let geoJson: Data = try? geoJ[0][0].rawData() {

                    var pointAnnotations = [CustomPointAnnotation]()

                        do {
                            let jsonData = try geoJ[0][0].rawData()
                            do {
                                if let jsonResult = try JSONSerialization.jsonObject(with: jsonData, options: JSONSerialization.ReadingOptions(rawValue: 0)) as? NSDictionary {
                                    if let personArray = jsonResult.value(forKey: "features") as? NSArray {
                                        for (_, element) in personArray.enumerated() {
                                            if let element = element as? NSDictionary {

                                                if let property = element["properties"] as? NSDictionary,
                                                    let geom = element["geometry"] as? NSDictionary, let coordinates = geom["coordinates"] as? NSArray

                                                {

                                                    let coordinates = geom["coordinates"] as! NSArray

                                                    let lat = coordinates[1] as! Double
                                                    let lng = coordinates[0] as! Double
                                                    let cordinate = CLLocationCoordinate2DMake(lat, lng)

                                                    if let name = property["f1"] as? String {
                                                        let point = CustomPointAnnotation(coordinate: cordinate, title: name, subtitle: "") as! CustomPointAnnotation
                                                        point.reuseIdentifier = "hidden_image"
                                                        point.image = UIImage(named: "tst")
                                                        pointAnnotations.append(point)
                                                    }

                                                }

                                            }
                                        }
                                    }
                                }
                            } catch let error as NSError {
                                print("Error: \(error)")
                            }
                        } catch let error as NSError {
                            print("Error: \(error)")
                        }

                    self.mapView.addAnnotations(pointAnnotations)

                }


            }

        })

    }

    func addLines() {
        /////////////
        let mapWorker = MapWorker()

        mapWorker.getGeomCollection(completion: { geomCollection in

            if let geomCollection = geomCollection {

                var coordinates: [CLLocationCoordinate2D] = []
                var coordinates3: [(Double, Double)] = []

                for geom in geomCollection.geomCollection {


                    for (idx, coord) in geom.coordinates.enumerated() {

                        if idx == geom.coordinates.endIndex {
                            break
                        }

                        coordinates.append(coord)

                        coordinates3.append((coord.longitude,coord.latitude))
                    }
                }

                coordinates.removeDuplicates()
                let c = coordinates.uniqueElements
                print(c.count)

                //                var i = 0
                //
                //                for geom in geomCollection.geomCollection {
                //                    if i == 2 {
                //                        //                        break
                //                    }
                //                    for coord in geom.coordinates {
                //                        coordinates.append(coord)
                //
                //                        coordinates3.append((coord.longitude,coord.latitude))
                //                    }
                //                    i = i + 1
                //                }

                //                coordinates = [
                //                    CLLocationCoordinate2D(latitude: 42.9162900002009, longitude: -73.7147929994514),
                //                    CLLocationCoordinate2D(latitude: 41.650086192867, longitude: -70.5443874377139)
                //                ].map({CLLocationCoordinate2D(latitude: $0.1, longitude: $0.0)})

                let coordinates2 = [
                    (-122.63748, 45.52214),
                    (-122.64855, 45.52218),
                    (-122.6545, 45.52219),
                    (-122.65497, 45.52196),
                    (-122.65631, 45.52104),
                    (-122.6578, 45.51935),
                    (-122.65867, 45.51848),
                    (-122.65872, 45.51293),
                    (-122.66576, 45.51295),
                    (-122.66745, 45.51252),
                    (-122.66813, 45.51244),
                    (-122.67359, 45.51385),
                    (-122.67415, 45.51406),
                    (-122.67481, 45.51484),
                    (-122.676, 45.51532),
                    (-122.68106, 45.51668),
                    (-122.68503, 45.50934),
                    (-122.68546, 45.50858),
                    (-122.6852, 45.50783),
                    (-122.68424, 45.50714),
                    (-122.68433, 45.50585),
                    (-122.68429, 45.50521),
                    (-122.68456, 45.50445),
                    (-122.68538, 45.50371),
                    (-122.68653, 45.50311),
                    (-122.68731, 45.50292),
                    (-122.68742, 45.50253),
                    (-122.6867, 45.50239),
                    (-122.68545, 45.5026),
                    (-122.68407, 45.50294),
                    (-122.68357, 45.50271),
                    (-122.68236, 45.50055),
                    (-122.68233, 45.49994),
                    (-122.68267, 45.49955),
                    (-122.68257, 45.49919),
                    (-122.68376, 45.49842),
                    (-122.68428, 45.49821),
                    (-122.68573, 45.49798),
                    (-122.68923, 45.49805),
                    (-122.68926, 45.49857),
                    (-122.68814, 45.49911),
                    (-122.68865, 45.49921),
                    (-122.6897, 45.49905),
                    (-122.69346, 45.49917),
                    (-122.69404, 45.49902),
                    (-122.69438, 45.49796),
                    (-122.69504, 45.49697),
                    (-122.69624, 45.49661),
                    (-122.69781, 45.4955),
                    (-122.69803, 45.49517),
                    (-122.69711, 45.49508),
                    (-122.69688, 45.4948),
                    (-122.69744, 45.49368),
                    (-122.69702, 45.49311),
                    (-122.69665, 45.49294),
                    (-122.69788, 45.49212),
                    (-122.69771, 45.49264),
                    (-122.69835, 45.49332),
                    (-122.7007, 45.49334),
                    (-122.70167, 45.49358),
                    (-122.70215, 45.49401),
                    (-122.70229, 45.49439),
                    (-122.70185, 45.49566),
                    (-122.70215, 45.49635),
                    (-122.70346, 45.49674),
                    (-122.70517, 45.49758),
                    (-122.70614, 45.49736),
                    (-122.70663, 45.49736),
                    (-122.70807, 45.49767),
                    (-122.70807, 45.49798),
                    (-122.70717, 45.49798),
                    (-122.70713, 45.4984),
                    (-122.70774, 45.49893)
                    ].map({CLLocationCoordinate2D(latitude: $0.1, longitude: $0.0)})

                var coordinates4 = coordinates3.map({CLLocationCoordinate2D(latitude: $0.1, longitude: $0.0)})

                self.allCoordinates = coordinates4

                let polyline = MGLPolyline(coordinates: coordinates, count: UInt(coordinates.count))
                self.mapView.addAnnotation(polyline)

                //                self.addPolyline(to: self.mapView.style!)
                //                self.animatePolyline()

                //                let polyline = MGLPolyline(coordinates: coordinates2, count: UInt(coordinates2.count))
                //
                //                self.mapView.addAnnotation(polyline)
            }

        })
    }

    

    @IBAction func testButtonTap(_ sender: Any) {

        //        addLinesv2()
        //        addLinesv4()

        //        addLinesv5()

        //        getTheShortestPathForStationsAB()
        //        getTheShortestPathForStationsABC()
        createHeatmap()
        addAnnotations()

        //        addPoints()

        //        addLines()

        ////////////

        //        mapWorker.getTestJSON(completion: { result in
        //            print("getTestJSON result: ", result)
        //            if let geoJSON = result  {
        //
        //
        //
        //
        //
        //                //                print(geoJSON[0])
        //                //                (try? JSONSerialization.jsonObject(with: jsonData, options: [])) as? [String: Any]
        //
        //                if let encryptedData: Data = try? geoJSON[0][0].rawData() {
        //
        //
        //                    let features = try? Features.fromGeoJSON(encryptedData) as! [Feature]
        //                    print(features)
        //                    //                    print(features??[0] as Any)
        //                    //                    print(features??[0].geometries)
        //                    //                    if let geom = features??[0].geometries {
        //                    //                        print(geom)
        //                    //                        print(geom[0])
        //                    //                        if let g = geom[0] as? LineString {
        //                    //                            print(g)
        //                    //                            print(g.points)
        //                    //                        }
        //                    //                    }
        //
        //                    //                    var coordinates: [CLLocationCoordinate2D] = []
        //
        //                    let coordinates = [
        //                        CLLocationCoordinate2D(latitude: 42.9162900002009, longitude: -73.7147929994514),
        //                        CLLocationCoordinate2D(latitude: 41.650086192867, longitude: -70.5443874377139)
        //                    ]
        //
        //                    for feature in features! {
        //                        if let geom = feature.geometries {
        //
        //                            // get line string from geom
        //                            if let g = geom.first as? LineString {
        //
        //                                // loop through all points
        //                                for point in g.points {
        //                                    //                                    print(point.x)
        //                                    //                                    print(point.y)
        //
        //                                    //                                    coordinates.append(CLLocationCoordinate2D(latitude: point.y, longitude: point.x))
        //
        //                                }
        //                            }
        //                        }
        //                    }
        //
        ////                    let polyline = MGLPolyline(coordinates: coordinates, count: UInt(coordinates.count))
        ////
        ////                    self.mapView.addAnnotation(polyline)
        //
        //
        //                }
        //
        //            }
        //        })
    }

    func dot(size: Int) -> UIImage {
        let floatSize = CGFloat(0.1)
        let rect = CGRect(x: 0, y: 0, width: floatSize, height: floatSize)
        let strokeWidth: CGFloat = 1

        UIGraphicsBeginImageContextWithOptions(rect.size, false, UIScreen.main.scale)

        let ovalPath = UIBezierPath(ovalIn: rect.insetBy(dx: strokeWidth, dy: strokeWidth))
        UIColor.darkGray.setFill()
        ovalPath.fill()

        UIColor.white.setStroke()
        ovalPath.lineWidth = strokeWidth
        ovalPath.stroke()

        let image: UIImage = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return image
    }

}

extension MapViewViewController: MGLMapViewDelegate {

    func mapView(_ mapView: MGLMapView, didFinishLoading style: MGLStyle) {
        //        let source = MGLVectorTileSource(identifier: "historical-places", configurationURL: URL(string: "mapbox://examples.5zzwbooj")!)
        //        style.addSource(source)
        //
        //        let layer = MGLCircleStyleLayer(identifier: "landmarks", source: source)
        //        layer.sourceLayerIdentifier = "HPC_landmarks-b60kqn"
        //        layer.circleColor = NSExpression(forConstantValue: #colorLiteral(red: 0.67, green: 0.28, blue: 0.13, alpha: 1))
        //        layer.circleOpacity = NSExpression(forConstantValue: 0.8)
        //        style.addLayer(layer)

        //        let mapWorker = MapWorker()
        //
        //        mapWorker.getGeomCollection(completion: { geomCollection in
        //
        //            if let geomCollection = geomCollection {
        //
        //                var coordinates: [CLLocationCoordinate2D] = []
        //
        //                for geom in geomCollection.geomCollection {
        //                    for coord in geom.coordinates {
        //                        coordinates.append(coord)
        //                    }
        //                }
        //                //
        //                //                var coordinates: [CLLocationCoordinate2D] = [
        //                //                    CLLocationCoordinate2D(latitude: 37.77, longitude: -122.42),
        //                //                    CLLocationCoordinate2D(latitude: 38.91, longitude: -77.04),
        //                //                    ]
        //                let polyline = MGLPolylineFeature(coordinates: &coordinates, count: UInt(coordinates.count))
        //                let source = MGLShapeSource(identifier: "lines", features: [polyline], options: nil)
        ////                self.mapView.style?.addSource(source)
        ////                self.mapView.reloadStyle(nil)
        ////
        ////                self.mapView.reloadInputViews()
        //                style.addSource(source)
        //
        //            }
        //
        //        })
    }

    func mapView(_ mapView: MGLMapView, alphaForShapeAnnotation annotation: MGLShape) -> CGFloat {
        // Set the alpha for all shape annotations to 1 (full opacity)
        return 1
    }

    func mapView(_ mapView: MGLMapView, lineWidthForPolylineAnnotation annotation: MGLPolyline) -> CGFloat {
        // Set the line width for polyline annotations
        return 2.0
    }

    //    func mapView(_ mapView: MGLMapView, strokeColorForShapeAnnotation annotation: MGLShape) -> UIColor {
    //        // Give our polyline a unique color by checking for its `title` property
    //        if (annotation.title == "Crema to Council Crest" && annotation is MGLPolyline) {
    //            // Mapbox cyan
    //            return UIColor(red: 59/255, green: 178/255, blue: 208/255, alpha: 1)
    //        } else {
    //            return .red
    //        }
    //    }

    // MARK: - MGLMapViewDelegate methods

    func mapView(_ mapView: MGLMapView, imageFor annotation: MGLAnnotation) -> MGLAnnotationImage? {
        if let point = annotation as? CustomPointAnnotation,
            let image = point.image,
            let reuseIdentifier = point.reuseIdentifier {

            if let annotationImage = mapView.dequeueReusableAnnotationImage(withIdentifier: reuseIdentifier) {
                // The annotatation image has already been cached, just reuse it.
                return annotationImage
            } else {
                // Create a new annotation image.
                return MGLAnnotationImage(image: image, reuseIdentifier: reuseIdentifier)
            }
        }

        // Fallback to the default marker image.
        return nil
    }

    func mapView(_ mapView: MGLMapView, strokeColorForShapeAnnotation annotation: MGLShape) -> UIColor {
        if let annotation = annotation as? CustomPolyline {
            // Return orange if the polyline does not have a custom color.
            return annotation.color ?? .orange
        }

        // Fallback to the default tint color.
        return mapView.tintColor
    }

    func mapView(_ mapView: MGLMapView, annotationCanShowCallout annotation: MGLAnnotation) -> Bool {
        return true
    }

    //    func mapView(_ mapView: MGLMapView, alphaForShapeAnnotation annotation: MGLShape) -> CGFloat {
    //        // Set the alpha for all shape annotations to 1 (full opacity)
    //        return 1
    //    }
    //
    //    func mapView(_ mapView: MGLMapView, lineWidthForPolylineAnnotation annotation: MGLPolyline) -> CGFloat {
    //        // Set the line width for polyline annotations
    //        return 2.0
    //    }
    //
    //    func mapView(_ mapView: MGLMapView, strokeColorForShapeAnnotation annotation: MGLShape) -> UIColor {
    //        // Give our polyline a unique color by checking for its `title` property
    //        if (annotation.title == "Crema to Council Crest" && annotation is MGLPolyline) {
    //            // Mapbox cyan
    //            return UIColor(red: 59/255, green: 178/255, blue: 208/255, alpha: 1)
    //        } else {
    //            return .red
    //        }
    //    }

}

public extension Sequence where Element: Equatable {
    var uniqueElements: [Element] {
        return self.reduce(into: []) {
            uniqueElements, element in

            if !uniqueElements.contains(element) {
                uniqueElements.append(element)
            }
        }
    }
}

extension Array where Element: Equatable {
    mutating func removeDuplicates() {
        var result = [Element]()
        for value in self {
            if !result.contains(value) {
                result.append(value)
            }
        }
        self = result
    }
}
